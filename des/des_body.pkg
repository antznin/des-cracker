use std.env.all;

use work.des_cst.all;

library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

package body des_pkg is

-- Initial and final permutations
function ip(w : w64)  return w64 is
           variable output : w64;
	   begin
	   for i in 1 to 64 loop 
             output(i) := w(ip_table(i));         
	   end loop;
	   return output;
end ip;	  

function iip(w1 : w32; w2:w32)  return w64 is
           variable input : w64;
           variable output : w64;
	   begin
	   input := w1&w2;
	   for i in 1 to 64 loop
             output(i) := input(iip_table(i));
	   end loop;
	   return output;
end iip;	

-- Key schedule functions
function left_shift (w:w28; amount : natural) return w28 is
  	   begin
	   if amount=2 then
	      return w(2 downto 1) & w(28 downto 3);
	   elsif amount=1 then
	      return w(1) & w(28 downto 2);
	   else
	      assert false report "ERROR" severity failure;
	   end if;
end left_shift;

function right_shift (w:w28; amount : natural) return w28 is
  	   begin
	   if amount=2 then
	      return w(26 downto 1) & w(28 downto 27);
	   elsif amount=1 then
	      return w(27 downto 1) & w(28);
	   else
	      assert false report "ERROR" severity failure;
	   end if;
end right_shift;

function pc1 (w : w64) return w56 is
           variable output1 : w28;
           variable output2 : w28;
           variable c : natural;
	   begin
	   for i in 1 to 28 loop
             output1(i) := w(pc1_table(i));
	   end loop;
           c:=28;
           for i in 1 to 28 loop
             c:=28+i;
             output2(i) := w(pc1_table(c));
	   end loop;
	   return output1&output2;
end pc1;	

function pc2(w1 : w28; w2 : w28) return w48 is
           variable input : w56;
           variable output : w48;
           begin
           input := w1&w2; 
           for i in 1 to 48 loop
             output(i) := input(pc2_table(i));
	   end loop;
	   return output;
end pc2;

-- Feistel functions
function p(w : w32) return w32 is
	variable output: w32;
begin
	for i in 1 to 32 loop
		output(i) := w(p_table(i));	
	end loop;	
	return output;
end p;

function e(w : w32) return w48 is
	variable output: w48;
begin
	for i in 1 to 48 loop
		output(i) := w(e_table(i));
	end loop;
	return output;
end e;

function s(w : w48) return w32 is
	variable output:     w32;
	variable sw:         w6;
	variable row, col:   integer;
	variable curr_table: table64_t;
	variable out_s:      w4;
begin
	output := (others => '0');
	for i in 1 to 8 loop
		curr_table := s_table(i);
		sw         := w(48-6*(i-1) downto 49-6*i);
		row        := to_integer(unsigned'(sw(6) & sw(1)));
		col        := to_integer(unsigned'(sw(5) & sw(4) & sw(3) & sw(2)));
		out_s      := std_ulogic_vector(to_unsigned(curr_table(row * 16 + col), out_s'length));
		output(32-4*(i-1) downto 33-4*i) := out_s;
	end loop;
	return output;
end s;

function f(r : w32; rk : w48) return w32 is
begin
	return p(s(e(r) xor rk));
end f;

-- DES main function
function des (p : w64; k : w56) return w64 is
	variable c: w64;
	variable l, r: w32;
begin
	p <= ip(p);
	l <= p(64 downto 33);
	r <= p(32 downto 1);
	for i in 1 to 16 loop
		l <= r;
		r <= l xor f(r, k_t(i));
	end loop;	
	c <= iip(r & l);
end des;


end package body des_pkg;
